# Домашнее задание к занятию "`Репликация и масштабирование. Часть 2`" - `Дёмин Максим`


### Задание 1

Что нужно сделать:

Опишите основные преимущества использования масштабирования методами:

активный master-сервер и пассивный репликационный slave-сервер;
master-сервер и несколько slave-серверов;

### Решение:

Преимущества масштабирования
1) Активный master + пассивный репликационный slave
(один основной сервер пишет, второй “догоняет” репликацией и обычно простаивает)

Плюсы:

Отказоустойчивость: если master упал — можно поднять slave как новый master и быстро восстановить работу.

Резерв для аварий: данные почти полностью продублированы.

Безопасное обслуживание master: часть задач можно делать на slave, не трогая боевой master.

Простой старт: минимальная сложность по сравнению с много реплик, легче понять и настроить новичку.

Снижение рисков при бэкапах: бэкап можно снимать со slave, меньше нагрузка на master.

Важно понимать: чтение с slave возможно, но обычно в такой схеме slave держат как запасной, чтобы не усложнять консистентность.

2) master + несколько slave
(один пишет, несколько читают)

Плюсы:

Масштабирование чтения: запросы SELECT можно распределять по нескольким slave - разгружаем master.

Изоляция нагрузок: можно выделить отдельный slave под:

отчёты/аналитику,

тяжёлые выборки,

бэкапы,

“поиск”, “каталог”, “витрины”.

Выше отказоустойчивость: потеря одного slave не критична, остаются другие.

Гибкость: можно добавлять реплики по мере роста нагрузки на чтение.

Дешевле, чем усиливать один сервер: часто проще добавить реплику, чем постоянно апгрейдить master.



### Задание 2

Что нужно сделать:

Разработайте план для выполнения горизонтального и вертикального шаринга базы данных. База данных состоит из трёх таблиц:

пользователи,
книги,
магазины (столбцы произвольно).
Опишите принципы построения системы и их разграничение или разбивку между базами данных.

Пришлите блоксхему, где и что будет располагаться. Опишите, в каких режимах будут работать сервера.

### Решение:

План горизонтального и вертикального шардинга (users, books, stores)

Что такое вертикальный и горизонтальный шардинг?
Вертикальный шардинг = “разносим разные таблицы по разным базам/серверам”.

Например: users живёт в одной БД, stores - в другой.

Горизонтальный шардинг = “одну и ту же таблицу делим по строкам на несколько серверов”.

Например: таблицу books делим на 2 шарда: часть книг на shard1, часть на shard2.

1) Вертикальный шардинг (разделяем по базам “по смыслу”)
Сделаем 3 логических зоны данных:

Users DB - всё про пользователей
Таблица: users

Stores DB - всё про магазины
Таблица: stores

Books Cluster - книги/каталог
Таблица: books, но она будет горизонтально разделена на 2 шарда.

users часто трогают при логине/профиле - своя БД.

stores обычно меньше по объёму - отдельная БД.

books часто самая большая (каталог) - её выгодно шардировать горизонтально.

2) Горизонтальный шардинг (делим таблицу books на 2 шарда)
Выбираем ключ шардирования для books. Самое простое - book_id.

Правило:

books_shard_1 хранит книги с нечётным book_id

books_shard_2 хранит книги с чётным book_id

То есть:

если book_id % 2 = 1 # shard 1

если book_id % 2 = 0 # shard 2

Это легко реализовать и объяснить.

3) Как система будет работать (принцип построения)

Обычно есть уровень приложения (API), который:

для users всегда ходит в Users DB

для stores всегда ходит в Stores DB

для books выбирает нужный shard по book_id

при шардинге JOIN между users и books внутри одной SQL-команды обычно не делают, потому что таблицы в разных БД/шардах. Делают склейку на уровне приложения.

4) Блок-схема (где что расположено)
```
[Client] -> [API]
              |-> [Users DB]  (users)
              |-> [Stores DB] (stores)
              |-> [Books Shard1] (books where id odd)
              \-> [Books Shard2] (books where id even)
 ```
<img width="1311" height="679" alt="mermaid-diagram" src="https://github.com/user-attachments/assets/8c0ffd0b-27ed-4e94-9be4-207ec73874f6" />
            
5) Режимы работы серверов (что с чтением/записью)
Users DB: primary (read/write)

Stores DB: primary (read/write)

Books Shard 1: primary шарда (read/write только для своей части данных)

Books Shard 2: primary шарда (read/write только для своей части данных)

### Задание 3

Что нужно сделать:

Выполните настройку выбранных методов шардинга из задания 2.

Пришлите конфиг Docker и SQL скрипт с командами для базы данных.

### Решение:

Запускаем [docker-compose.yml](sharding-demo/docker-compose.yml)
```
docker compose up -d
```
Проверка users
```
psql "postgresql://app:app@localhost:5433/users_db" -c "select * from users;"
```
Проверка stores
```
psql "postgresql://app:app@localhost:5434/stores_db" -c "select * from stores;"
```
Проверка books shard 1
```
psql "postgresql://app:app@localhost:5435/books_db" -c "select book_id, title from books order by book_id;"
```
Проверка books shard 2
```
psql "postgresql://app:app@localhost:5436/books_db" -c "select book_id, title from books order by book_id;"
```

Как в приложении выбирать shard 

Хотим книгу по book_id:

если book_id % 2 == 1 → идём в books-shard-1

если book_id % 2 == 0 → идём в books-shard-2

Если создаём новую книгу:

можно создавать на любом шарде (там свой sequence), но обычно делают “единый сервис каталога”, который сам выбирает shard.

Добавить пользователя
```
psql "postgresql://app:app@localhost:5433/users_db" -c \
"INSERT INTO users(email, full_name) VALUES
 ('petr@example.com','Petr Petrov'),
 ('anna@example.com','Anna Smirnova')
RETURNING *;"
```

Добавить магазин
```
psql "postgresql://app:app@localhost:5434/stores_db" -c \
"INSERT INTO stores(name, city, address) VALUES ('BookShop #3','Madrid','Gran Via 1') RETURNING *;"
```

Добавить книгу на shard1
```
psql "postgresql://app:app@localhost:5435/books_db" -c \
"INSERT INTO books(title, author, price) VALUES ('Auto Book S1','Author S1',9.99) RETURNING book_id,title;"
```

Добавить книгу на shard2
```
psql "postgresql://app:app@localhost:5436/books_db" -c \
"INSERT INTO books(title, author, price) VALUES ('Auto Book S2','Author S2',11.99) RETURNING book_id,title;"
```
